import 'package:startlink/core/services/supabase_client.dart';
import 'package:startlink/features/idea/data/models/idea_model.dart';
import 'package:startlink/features/idea/domain/entities/idea.dart';
import 'package:startlink/features/idea/domain/repositories/idea_repository.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class IdeaRepositoryImpl implements IdeaRepository {
  final SupabaseClient _supabase;

  IdeaRepositoryImpl({SupabaseClient? supabase})
    : _supabase = supabase ?? SupabaseService.client;

  @override
  Future<List<Idea>> fetchMyIdeas() async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) {
        throw Exception('User not logged in');
      }

      final response = await _supabase
          .from('ideas')
          .select()
          .eq('owner_id', userId)
          .order('created_at', ascending: false);

      return (response as List).map((e) => IdeaModel.fromJson(e)).toList();
    } catch (e) {
      throw Exception('Failed to fetch ideas: $e');
    }
  }

  @override
  Future<void> createIdea(Idea idea) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) {
        throw Exception('User not logged in');
      }

      // Ensure the idea has the correct owner_id - security precaution
      final ideaModel = IdeaModel(
        id: idea
            .id, // ID might be ignored by Supabase if auto-generated, but we pass it for now or handle it.
        // Actually, for creation, ID is usually generated by DB.
        // But IdeaModel requires ID. We might need to handle this.
        // Let's assume we pass a placeholder ID or generate a UUID if client-side gen is allowed.
        // For Supabase, usually we omit ID for auto-increment/uuid-gen.
        // However, IdeaModel.toJson includes everything.
        // We should probably rely on the passed idea, but ensure ownerId.
        title: idea.title,
        description: idea.description,
        ownerId: userId,
        problemStatement: idea.problemStatement,
        targetMarket: idea.targetMarket,
        currentStage: idea.currentStage,
        isPublic: idea.isPublic,
        tags: idea.tags,
        status: idea.status,
        aiQualityScore: idea.aiQualityScore,
      );

      // Convert to JSON and remove 'id' if it's a new record (if necessary),
      // OR just rely on upsert logic if ID is provided.
      // Since this is 'create', let's assume 'insert'.
      final json = ideaModel.toJson();
      if (idea.id.isEmpty) {
        json.remove('id'); // Remove ID so DB generates it
      }

      await _supabase.from('ideas').insert(json);
    } catch (e) {
      throw Exception('Failed to create idea: $e');
    }
  }

  @override
  Future<void> updateIdea(Idea idea) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) {
        throw Exception('User not logged in');
      }

      final ideaModel = IdeaModel(
        id: idea.id,
        title: idea.title,
        description: idea.description,
        ownerId: userId,
        problemStatement: idea.problemStatement,
        targetMarket: idea.targetMarket,
        currentStage: idea.currentStage,
        isPublic: idea.isPublic,
        tags: idea.tags,
        status: idea.status,
        aiQualityScore: idea.aiQualityScore,
      );

      final json = ideaModel.toJson();
      // Remove owner_id to prevent ownership transfer (though RLS should handle it)
      json.remove('owner_id');
      // Remove id from update payload usually, as it's the selector
      json.remove('id');

      await _supabase
          .from('ideas')
          .update(json)
          .eq('id', idea.id)
          .eq('owner_id', userId); // Extra safety
    } catch (e) {
      throw Exception('Failed to update idea: $e');
    }
  }
}
